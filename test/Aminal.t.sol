// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console} from "lib/forge-std/src/Test.sol";
import {Aminal} from "src/Aminal.sol";
import {IGenes} from "src/interfaces/IGenes.sol";
import {SqueakSkill} from "src/skills/SqueakSkill.sol";

contract AminalTest is Test {
    Aminal public aminal;
    SqueakSkill public squeakSkill;
    address public user1;
    address public user2;
    string public constant BASE_URI = "https://api.aminals.com/metadata/";
    string public constant NAME = "Fire Dragon";
    string public constant SYMBOL = "FDRAGON";

    event AminalCreated(uint256 indexed tokenId, address indexed owner, string tokenURI);
    event BaseURIUpdated(string newBaseURI);
    event LoveReceived(address indexed from, uint256 amount, uint256 totalLove);
    event EnergyGained(address indexed from, uint256 amount, uint256 newEnergy);
    event EnergyLost(address indexed squeaker, uint256 amount, uint256 newEnergy);
    event LoveConsumed(address indexed squeaker, uint256 amount, uint256 remainingLove);
    event SkillUsed(address indexed user, address indexed target, uint256 cost, bytes4 selector);

    function setUp() external {
        user1 = makeAddr("user1");
        user2 = makeAddr("user2");
        
        // Deploy SqueakSkill
        squeakSkill = new SqueakSkill();
        
        // Create sample traits
        IGenes.Genes memory traits = IGenes.Genes({
            back: "Dragon Wings",
            arm: "Scaled Arms",
            tail: "Fire Tail",
            ears: "Pointed Ears",
            body: "Dragon Body",
            face: "Fierce Face",
            mouth: "Fire Breath",
            misc: "Golden Scales"
        });
        
        // Deploy self-sovereign Aminal
        aminal = new Aminal(NAME, SYMBOL, BASE_URI, traits);
    }

    function test_Constructor() external {
        assertEq(aminal.name(), NAME);
        assertEq(aminal.symbol(), SYMBOL);
        assertEq(aminal.totalSupply(), 0);
        assertEq(aminal.TOKEN_ID(), 1);
        assertFalse(aminal.minted());
        assertFalse(aminal.initialized());
    }

    function test_ConstructorSelfSovereign() external {
        IGenes.Genes memory traits = IGenes.Genes({
            back: "Dragon Wings",
            arm: "Scaled Arms",
            tail: "Fire Tail",
            ears: "Pointed Ears",
            body: "Dragon Body",
            face: "Fierce Face",
            mouth: "Fire Breath",
            misc: "Golden Scales"
        });
        
        // Self-sovereign Aminal should deploy successfully
        Aminal selfSovereignAminal = new Aminal(NAME, SYMBOL, BASE_URI, traits);
        
        assertEq(selfSovereignAminal.name(), NAME);
        assertEq(selfSovereignAminal.symbol(), SYMBOL);
        assertFalse(selfSovereignAminal.initialized());
    }

    function test_Initialize() external {
        string memory tokenURI = "firedragon.json";
        
        vm.expectEmit(true, true, false, true);
        emit AminalCreated(1, address(aminal), tokenURI);
        
        uint256 tokenId = aminal.initialize(tokenURI);
        
        assertEq(tokenId, 1);
        assertEq(aminal.ownerOf(tokenId), address(aminal)); // Aminal owns itself!
        // tokenURI is now dynamically generated by renderer, so we just check it's not empty
        assertTrue(bytes(aminal.tokenURI(tokenId)).length > 0);
        assertEq(aminal.totalSupply(), 1);
        assertTrue(aminal.exists(tokenId));
        assertTrue(aminal.minted());
        assertTrue(aminal.initialized());
    }

    function test_RevertWhen_InitializeTwice() external {
        string memory tokenURI = "firedragon.json";
        
        // First initialization should succeed
        aminal.initialize(tokenURI);
        
        // Second initialization should fail due to already minted
        vm.expectRevert(Aminal.AlreadyMinted.selector);
        aminal.initialize("firedragon2.json");
    }

    function test_InitializeByAnyoneSucceeds() external {
        string memory tokenURI = "firedragon.json";
        
        // Anyone can initialize the Aminal
        vm.prank(user1);
        uint256 tokenId = aminal.initialize(tokenURI);
        
        assertEq(tokenId, 1);
        assertEq(aminal.ownerOf(tokenId), address(aminal));
        assertTrue(aminal.initialized());
    }

    function test_RevertWhen_InitializeAfterMinted() external {
        string memory tokenURI = "firedragon.json";
        
        // Initialize (mints token)
        aminal.initialize(tokenURI);
        
        // Cannot initialize again due to minted flag
        vm.expectRevert(Aminal.AlreadyMinted.selector);
        aminal.initialize("firedragon2.json");
    }

    function test_SetBaseURI() external {
        string memory newBaseURI = "https://newapi.aminals.com/metadata/";
        
        // Only the contract itself can set base URI
        vm.prank(address(aminal));
        vm.expectEmit(false, false, false, true);
        emit BaseURIUpdated(newBaseURI);
        
        aminal.setBaseURI(newBaseURI);
        
        // Initialize with new base URI
        uint256 tokenId = aminal.initialize("firedragon.json");
        
        // tokenURI is now dynamically generated by renderer
        assertTrue(bytes(aminal.tokenURI(tokenId)).length > 0);
    }

    function test_RevertWhen_SetBaseURICalledByNonSelf() external {
        vm.prank(user1);
        vm.expectRevert(Aminal.NotAuthorized.selector);
        aminal.setBaseURI("https://newapi.aminals.com/metadata/");
    }

    function test_RevertWhen_TransferFrom() external {
        uint256 tokenId = aminal.initialize("firedragon.json");
        
        // Aminal owns itself initially
        assertEq(aminal.ownerOf(tokenId), address(aminal));
        
        // Any transfer attempt should revert
        vm.prank(address(aminal));
        vm.expectRevert(Aminal.TransferNotAllowed.selector);
        aminal.transferFrom(address(aminal), user1, tokenId);
        
        // Verify Aminal still owns itself
        assertEq(aminal.ownerOf(tokenId), address(aminal));
    }

    function test_RevertWhen_SafeTransferFrom() external {
        uint256 tokenId = aminal.initialize("firedragon.json");
        
        // Any safe transfer attempt should revert
        vm.prank(address(aminal));
        vm.expectRevert(Aminal.TransferNotAllowed.selector);
        aminal.safeTransferFrom(address(aminal), user1, tokenId);
        
        // Verify Aminal still owns itself
        assertEq(aminal.ownerOf(tokenId), address(aminal));
    }

    function test_RevertWhen_SafeTransferFromWithData() external {
        uint256 tokenId = aminal.initialize("firedragon.json");
        
        // Any safe transfer with data attempt should revert
        vm.prank(address(aminal));
        vm.expectRevert(Aminal.TransferNotAllowed.selector);
        aminal.safeTransferFrom(address(aminal), user1, tokenId, "data");
        
        // Verify Aminal still owns itself
        assertEq(aminal.ownerOf(tokenId), address(aminal));
    }

    function test_RevertWhen_Approve() external {
        aminal.initialize("firedragon.json");
        
        // Any approval attempt should revert
        vm.prank(address(aminal));
        vm.expectRevert(Aminal.TransferNotAllowed.selector);
        aminal.approve(user1, 1);
    }

    function test_RevertWhen_SetApprovalForAll() external {
        aminal.initialize("firedragon.json");
        
        // Any approval for all attempt should revert
        vm.prank(address(aminal));
        vm.expectRevert(Aminal.TransferNotAllowed.selector);
        aminal.setApprovalForAll(user1, true);
    }

    function test_PermanentSelfOwnership() external {
        uint256 tokenId = aminal.initialize("firedragon.json");
        
        // Verify permanent self-ownership
        assertEq(aminal.ownerOf(tokenId), address(aminal));
        assertEq(aminal.balanceOf(address(aminal)), 1);
        assertEq(aminal.balanceOf(user1), 0);
        assertEq(aminal.balanceOf(user2), 0);
        
        // Verify no approvals are possible
        assertEq(aminal.getApproved(tokenId), address(0));
        assertFalse(aminal.isApprovedForAll(address(aminal), user1));
    }

    function test_Exists() external {
        assertFalse(aminal.exists(1));
        assertFalse(aminal.exists(2));
        
        uint256 tokenId = aminal.initialize("firedragon.json");
        
        assertTrue(aminal.exists(tokenId));
        assertFalse(aminal.exists(2));
    }

    function test_IsMinted() external {
        assertFalse(aminal.minted());
        
        aminal.initialize("firedragon.json");
        
        assertTrue(aminal.minted());
    }

    function test_TotalSupply() external {
        assertEq(aminal.totalSupply(), 0);
        
        aminal.initialize("firedragon.json");
        
        assertEq(aminal.totalSupply(), 1);
    }

    function test_PublicVariableAccess() external {
        // Test direct access to public variables
        assertFalse(aminal.minted());
        assertFalse(aminal.initialized());
        assertEq(aminal.baseTokenURI(), BASE_URI);
        assertEq(aminal.TOKEN_ID(), 1);
        
        aminal.initialize("firedragon.json");
        
        // Verify public variables updated
        assertTrue(aminal.minted());
        assertTrue(aminal.initialized());
    }

    function test_Traits() external {
        // Test getTraits function
        IGenes.Genes memory traits = aminal.getTraits();
        assertEq(traits.back, "Dragon Wings");
        assertEq(traits.arm, "Scaled Arms");
        assertEq(traits.tail, "Fire Tail");
        assertEq(traits.ears, "Pointed Ears");
        assertEq(traits.body, "Dragon Body");
        assertEq(traits.face, "Fierce Face");
        assertEq(traits.mouth, "Fire Breath");
        assertEq(traits.misc, "Golden Scales");
    }

    function test_SupportsInterface() external {
        // ERC721 interface
        assertTrue(aminal.supportsInterface(0x80ac58cd));
        // ERC721Metadata interface
        assertTrue(aminal.supportsInterface(0x5b5e139f));
        // ERC165 interface
        assertTrue(aminal.supportsInterface(0x01ffc9a7));
    }

    function testFuzz_Initialize(string memory tokenURI) external {
        vm.assume(bytes(tokenURI).length > 0);
        
        uint256 tokenId = aminal.initialize(tokenURI);
        
        assertEq(tokenId, 1);
        assertEq(aminal.ownerOf(tokenId), address(aminal)); // Self-owned
        assertTrue(aminal.exists(tokenId));
        assertTrue(aminal.minted());
        assertTrue(aminal.initialized());
    }

    function testFuzz_SetBaseURI(string memory newBaseURI) external {
        // Skip this test as tokenURI is now dynamically generated by renderer
        vm.skip(true);
        return;
        // Only the contract itself can set base URI
        vm.prank(address(aminal));
        aminal.setBaseURI(newBaseURI);
        
        uint256 tokenId = aminal.initialize("test.json");
        
        assertEq(aminal.tokenURI(tokenId), string(abi.encodePacked(newBaseURI, "test.json")));
    }

    function test_ReceiveLove() external {
        uint256 ethAmount = 1 ether;
        uint256 expectedLove = 100000; // 10,000 base units × 10x multiplier at 0 energy
        uint256 expectedEnergy = 10000; // 10,000 energy per ETH
        
        // Check initial state
        assertEq(aminal.totalLove(), 0);
        assertEq(aminal.loveFromUser(user1), 0);
        assertEq(aminal.energy(), 0);
        assertEq(address(aminal).balance, 0);
        
        // Send ETH and expect events
        vm.prank(user1);
        vm.expectEmit(true, false, false, true);
        emit LoveReceived(user1, expectedLove, expectedLove);
        vm.expectEmit(true, false, false, true);
        emit EnergyGained(user1, expectedEnergy, expectedEnergy);
        
        vm.deal(user1, ethAmount);
        (bool success,) = address(aminal).call{value: ethAmount}("");
        assertTrue(success);
        
        // Verify love and energy tracking
        assertEq(aminal.totalLove(), expectedLove);
        assertEq(aminal.loveFromUser(user1), expectedLove);
        assertEq(aminal.energy(), expectedEnergy);
        assertEq(aminal.getTotalLove(), expectedLove);
        assertEq(aminal.getLoveFromUser(user1), expectedLove);
        assertEq(aminal.getEnergy(), expectedEnergy);
        assertEq(address(aminal).balance, ethAmount);
    }

    function test_MultipleLoveTransactions() external {
        uint256 firstETH = 0.5 ether;
        uint256 secondETH = 0.3 ether;
        uint256 totalETH = firstETH + secondETH;
        
        vm.deal(user1, totalETH);
        vm.deal(user2, 1 ether);
        
        // First feed from user1 at 0 energy (10x multiplier)
        uint256 firstLove = 50000; // 5,000 base × 10x
        vm.prank(user1);
        vm.expectEmit(true, false, false, true);
        emit LoveReceived(user1, firstLove, firstLove);
        (bool success,) = address(aminal).call{value: firstETH}("");
        assertTrue(success);
        
        // Second feed from user1 at 5000 energy
        uint256 secondLoveExpected = aminal.calculateLoveForETH(secondETH);
        uint256 totalLoveUser1 = firstLove + secondLoveExpected;
        vm.prank(user1);
        vm.expectEmit(true, false, false, true);
        emit LoveReceived(user1, secondLoveExpected, totalLoveUser1);
        (success,) = address(aminal).call{value: secondETH}("");
        assertTrue(success);
        
        // Feed from user2 at higher energy
        uint256 user2ETH = 0.7 ether;
        uint256 user2Love = aminal.calculateLoveForETH(user2ETH);
        vm.prank(user2);
        vm.expectEmit(true, false, false, true);
        emit LoveReceived(user2, user2Love, totalLoveUser1 + user2Love);
        (success,) = address(aminal).call{value: user2ETH}("");
        assertTrue(success);
        
        // Verify final state
        assertEq(aminal.totalLove(), totalLoveUser1 + user2Love);
        assertEq(aminal.loveFromUser(user1), totalLoveUser1);
        assertEq(aminal.loveFromUser(user2), user2Love);
        assertEq(address(aminal).balance, totalETH + user2ETH);
    }

    function test_ZeroValueLove() external {
        // Sending 0 ETH should not emit event or update state
        vm.prank(user1);
        (bool success,) = address(aminal).call{value: 0}("");
        assertTrue(success);
        
        assertEq(aminal.totalLove(), 0);
        assertEq(aminal.loveFromUser(user1), 0);
        assertEq(address(aminal).balance, 0);
    }

    function testFuzz_ReceiveLove(uint96 amount) external {
        vm.assume(amount > 0);
        vm.assume(amount <= 10 ether); // Keep within reasonable bounds
        
        vm.deal(user1, amount);
        vm.prank(user1);
        
        (bool success,) = address(aminal).call{value: amount}("");
        assertTrue(success);
        
        // Calculate expected love based on VRGDA at 0 energy
        uint256 expectedLove = aminal.loveFromUser(user1);
        uint256 expectedEnergy = (uint256(amount) * 10000) / 1 ether;
        
        assertEq(aminal.totalLove(), expectedLove);
        assertEq(aminal.energy(), expectedEnergy);
        assertEq(address(aminal).balance, amount);
    }

    function test_LoveQueryFunctions() external {
        uint256 ethAmount = 2 ether;
        uint256 expectedLove = 200000; // 20,000 base units × 10x at 0 energy
        
        vm.deal(user1, ethAmount);
        vm.prank(user1);
        (bool success,) = address(aminal).call{value: ethAmount}("");
        assertTrue(success);
        
        // Test getter functions
        assertEq(aminal.getTotalLove(), expectedLove);
        assertEq(aminal.getLoveFromUser(user1), expectedLove);
        assertEq(aminal.getLoveFromUser(user2), 0);
        
        // Test public variables
        assertEq(aminal.totalLove(), expectedLove);
        assertEq(aminal.loveFromUser(user1), expectedLove);
        assertEq(aminal.loveFromUser(user2), 0);
    }

    function test_EnergySystem() external {
        uint256 feedAmount = 2 ether;
        uint256 expectedLove = 200000; // 20,000 base units × 10x multiplier at 0 energy
        uint256 expectedEnergy = 20000; // 10,000 per ETH
        uint256 squeakAmount = 5000; // Squeak in energy units
        
        // Check initial energy
        assertEq(aminal.energy(), 0);
        assertEq(aminal.getEnergy(), 0);
        
        // Feed the Aminal (send ETH)
        vm.deal(user1, feedAmount);
        vm.prank(user1);
        vm.expectEmit(true, false, false, true);
        emit EnergyGained(user1, expectedEnergy, expectedEnergy);
        (bool success,) = address(aminal).call{value: feedAmount}("");
        assertTrue(success);
        
        // Verify energy increased
        assertEq(aminal.energy(), expectedEnergy);
        assertEq(aminal.getEnergy(), expectedEnergy);
        
        // Make the Aminal squeak - user1 has love so they can squeak
        vm.prank(user1);
        vm.expectEmit(true, false, false, true);
        emit EnergyLost(user1, squeakAmount, expectedEnergy - squeakAmount);
        vm.expectEmit(true, false, false, true);
        emit LoveConsumed(user1, squeakAmount, expectedLove - squeakAmount);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, squeakAmount));
        
        // Verify energy and love decreased
        assertEq(aminal.energy(), expectedEnergy - squeakAmount);
        assertEq(aminal.getEnergy(), expectedEnergy - squeakAmount);
        assertEq(aminal.loveFromUser(user1), expectedLove - squeakAmount);
        assertEq(aminal.totalLove(), expectedLove - squeakAmount);
    }

    function test_RevertWhen_InsufficientEnergy() external {
        uint256 feedAmount = 0.0005 ether;
        uint256 energy = 5; // 5 energy (0.0005 ETH * 10,000)
        uint256 squeakAmount = 10; // More than available energy
        
        // Feed the Aminal with very small amount
        vm.deal(user1, feedAmount);
        vm.prank(user1);
        (bool success,) = address(aminal).call{value: feedAmount}("");
        assertTrue(success);
        
        // Try to squeak more than available energy
        vm.prank(user1);
        vm.expectRevert(Aminal.InsufficientEnergy.selector);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, squeakAmount));
        
        // Energy should remain unchanged
        assertEq(aminal.energy(), energy);
    }

    function test_SqueakWithZeroEnergy() external {
        // Try to squeak with no energy
        vm.prank(user1);
        vm.expectRevert(Aminal.InsufficientEnergy.selector);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, 1));
        
        assertEq(aminal.energy(), 0);
    }

    function test_SqueakExactEnergyAmount() external {
        uint256 feedAmount = 1 ether;
        uint256 expectedLove = 100000; // 10,000 base × 10x multiplier at 0 energy
        uint256 expectedEnergy = 10000; // 10,000 energy per ETH
        
        // Feed the Aminal
        vm.deal(user1, feedAmount);
        vm.prank(user1);
        (bool success,) = address(aminal).call{value: feedAmount}("");
        assertTrue(success);
        
        // Squeak exact amount of energy available
        vm.prank(user1);
        vm.expectEmit(true, false, false, true);
        emit EnergyLost(user1, expectedEnergy, 0);
        vm.expectEmit(true, false, false, true);
        emit LoveConsumed(user1, expectedEnergy, expectedLove - expectedEnergy);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, expectedEnergy));
        
        // Energy should be zero, love should be reduced by energy amount
        assertEq(aminal.energy(), 0);
        assertEq(aminal.loveFromUser(user1), expectedLove - expectedEnergy);
        assertEq(aminal.totalLove(), expectedLove - expectedEnergy);
    }

    function test_MultipleFeedings() external {
        uint256 firstFeed = 1 ether;
        uint256 secondFeed = 0.5 ether;
        uint256 firstEnergy = 10000; // 10,000 per ETH
        uint256 secondEnergy = 5000; // 5,000 for 0.5 ETH
        uint256 totalEnergy = firstEnergy + secondEnergy;
        
        vm.deal(user1, firstFeed);
        vm.deal(user2, secondFeed);
        
        // First feeding
        vm.prank(user1);
        vm.expectEmit(true, false, false, true);
        emit EnergyGained(user1, firstEnergy, firstEnergy);
        (bool success,) = address(aminal).call{value: firstFeed}("");
        assertTrue(success);
        
        // Second feeding
        vm.prank(user2);
        vm.expectEmit(true, false, false, true);
        emit EnergyGained(user2, secondEnergy, totalEnergy);
        (success,) = address(aminal).call{value: secondFeed}("");
        assertTrue(success);
        
        // Verify total energy
        assertEq(aminal.energy(), totalEnergy);
    }

    function testFuzz_EnergySystem(uint96 feedAmount, uint96 squeakAmount) external {
        vm.assume(feedAmount > 0);
        vm.assume(feedAmount <= 10 ether); // Keep within reasonable bounds
        
        // Feed the Aminal
        vm.deal(user1, feedAmount);
        vm.prank(user1);
        (bool success,) = address(aminal).call{value: feedAmount}("");
        assertTrue(success);
        
        uint256 energy = aminal.energy();
        uint256 love = aminal.loveFromUser(user1);
        
        // Only test squeaking within available bounds
        vm.assume(squeakAmount <= energy && squeakAmount <= love);
        
        if (squeakAmount > 0) {
            // Cap squeakAmount at 10000 due to safety cap in Aminal contract
            uint256 actualSqueakAmount = squeakAmount > 10000 ? 10000 : squeakAmount;
            
            // Squeak
            vm.prank(user1);
            aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, squeakAmount));
            
            assertEq(aminal.energy(), energy - actualSqueakAmount);
            assertEq(aminal.loveFromUser(user1), love - actualSqueakAmount);
        }
    }

    function test_RevertWhen_InsufficientLove() external {
        uint256 feedAmount = 1 ether;
        uint256 squeakAmount = 5000; // Squeak amount in energy units
        uint256 expectedLove = 100000; // 10,000 base × 10x multiplier at 0 energy
        uint256 expectedEnergy = 10000; // 10,000 energy per ETH
        
        // Feed the Aminal from user1
        vm.deal(user1, feedAmount);
        vm.prank(user1);
        (bool success,) = address(aminal).call{value: feedAmount}("");
        assertTrue(success);
        
        // user2 has no love, so they can't squeak
        vm.prank(user2);
        vm.expectRevert(Aminal.InsufficientLove.selector);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, squeakAmount));
        
        // Energy and love should remain unchanged
        assertEq(aminal.energy(), expectedEnergy);
        assertEq(aminal.loveFromUser(user1), expectedLove);
        assertEq(aminal.loveFromUser(user2), 0);
        assertEq(aminal.totalLove(), expectedLove);
    }

    function test_SqueakWithPartialLove() external {
        // This test verifies the InsufficientLove error
        // Strategy: Create a scenario where a user has less love than available energy
        
        // Step 1: User1 feeds a small amount to get some love
        uint256 smallFeed = 0.0001 ether;
        vm.deal(user1, smallFeed);
        vm.prank(user1);
        (bool success,) = address(aminal).call{value: smallFeed}("");
        assertTrue(success);
        
        // User1 has 10 love units (1 energy × 10x multiplier), energy is 1
        uint256 user1InitialLove = 10; // 1 unit × 10x at 0 energy
        
        // Step 2: User2 feeds a large amount to add lots of energy
        uint256 largeFeed = 1 ether;
        vm.deal(user2, largeFeed);
        vm.prank(user2);
        (success,) = address(aminal).call{value: largeFeed}("");
        assertTrue(success);
        
        // Now energy is 1 + 10,000 = 10,001
        // User1 still has only 10 love units
        
        // Step 3: User1 tries to squeak more than their love (but less than energy)
        uint256 user1Love = aminal.loveFromUser(user1);
        assertEq(user1Love, user1InitialLove);
        
        // Try to squeak more than they have
        vm.prank(user1);
        vm.expectRevert(Aminal.InsufficientLove.selector);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, user1Love + 1));
        
        // Step 4: User1 can squeak exactly their love amount
        vm.prank(user1);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, user1Love));
        
        // Verify user1 has no love left
        assertEq(aminal.loveFromUser(user1), 0);
        
        // Step 5: User1 can't squeak anymore (no love)
        vm.prank(user1);
        vm.expectRevert(Aminal.InsufficientLove.selector);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, 1));
    }

    function test_MultipleSqueaksFromDifferentUsers() external {
        uint256 feedAmount = 1 ether;
        uint256 squeakAmount = 3000; // Squeak in energy units
        
        // User1 feeds at 0 energy (10x multiplier)
        vm.deal(user1, feedAmount);
        vm.prank(user1);
        (bool success,) = address(aminal).call{value: feedAmount}("");
        assertTrue(success);
        
        uint256 user1Love = 100000; // 10,000 base × 10x at 0 energy
        uint256 energyAfterUser1 = 10000;
        
        // Calculate love for user2 at current energy level
        uint256 user2Love = aminal.calculateLoveForETH(feedAmount);
        
        // User2 feeds at higher energy (lower multiplier)
        vm.deal(user2, feedAmount);
        vm.prank(user2);
        (success,) = address(aminal).call{value: feedAmount}("");
        assertTrue(success);
        
        uint256 totalEnergy = 20000; // 10k + 10k
        
        // Both users squeak
        vm.prank(user1);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, squeakAmount));
        
        vm.prank(user2);
        aminal.useSkill(address(squeakSkill), abi.encodeWithSelector(SqueakSkill.squeak.selector, squeakAmount));
        
        // Verify final state
        assertEq(aminal.energy(), totalEnergy - 2 * squeakAmount);
        assertEq(aminal.loveFromUser(user1), user1Love - squeakAmount);
        assertEq(aminal.loveFromUser(user2), user2Love - squeakAmount);
        assertEq(aminal.totalLove(), user1Love + user2Love - 2 * squeakAmount);
    }
}