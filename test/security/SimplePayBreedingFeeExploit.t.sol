// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console2} from "forge-std/Test.sol";
import {Aminal} from "src/Aminal.sol";
import {IGenes} from "src/interfaces/IGenes.sol";

/**
 * @title SimplePayBreedingFeeExploit
 * @notice Demonstrates the critical security vulnerability in payBreedingFee
 * @dev This shows how anyone can drain ETH from any Aminal
 */
contract SimplePayBreedingFeeExploit is Test {
    Aminal public vulnerableAminal;
    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");
    
    // Mock factory function to return no breeding vote contract
    function breedingVoteContract() external pure returns (address) {
        return address(0); // No authorized contract
    }
    
    function setUp() public {
        // Create a vulnerable Aminal
        IGenes.Genes memory genes = IGenes.Genes({
            back: "Dragon",
            arm: "Strong",
            tail: "Long",
            ears: "Pointy",
            body: "Scaled",
            face: "Fierce",
            mouth: "Fire",
            misc: "Wings"
        });
        
        // Create vulnerable Aminal with mock factory
        vulnerableAminal = new Aminal("VulnerableAminal", "VULN", "", genes, address(this));
        vulnerableAminal.initialize("ipfs://vulnerable");
        
        // Fund the Aminal (simulating a valuable NFT)
        vm.deal(victim, 100 ether);
        vm.prank(victim);
        (bool success,) = address(vulnerableAminal).call{value: 100 ether}("");
        require(success, "Failed to fund aminal");
        
        // Give attacker some gas money
        vm.deal(attacker, 1 ether);
    }
    
    function test_FIXED_UnauthorizedCallsNowRevert() public {
        console2.log("=== SECURITY FIX VERIFICATION ===");
        console2.log("Aminal balance before attack attempt:", address(vulnerableAminal).balance);
        console2.log("Attacker balance before:", attacker.balance);
        
        // ATTACK ATTEMPT: Any external address tries to call payBreedingFee
        vm.startPrank(attacker);
        
        address[] memory recipients = new address[](1);
        recipients[0] = attacker;
        
        // Attack should now fail with authorization error
        vm.expectRevert("Only authorized breeding vote contract");
        vulnerableAminal.payBreedingFee(recipients, 999999);
        
        vm.stopPrank();
        
        // Verify no funds were stolen
        assertEq(address(vulnerableAminal).balance, 100 ether); // Balance unchanged
        assertEq(attacker.balance, 1 ether); // Attacker still has only gas money
        
        console2.log("\n[SECURITY FIX] payBreedingFee now has authorization checks!");
        console2.log("[RESULT] Unauthorized calls are rejected");
    }
    
    function test_FIXED_AllUnauthorizedCallsFail() public {
        console2.log("=== ALL ATTACK VECTORS NOW BLOCKED ===");
        
        address[] memory recipients = new address[](1);
        recipients[0] = attacker;
        
        vm.startPrank(attacker);
        
        // All these should fail with authorization error
        vm.expectRevert("Only authorized breeding vote contract");
        vulnerableAminal.payBreedingFee(recipients, 0);
        
        vm.expectRevert("Only authorized breeding vote contract");
        vulnerableAminal.payBreedingFee(recipients, type(uint256).max);
        
        vm.expectRevert("Only authorized breeding vote contract");
        vulnerableAminal.payBreedingFee(recipients, 42);
        
        vm.stopPrank();
        
        console2.log("[SECURITY FIX] Authorization required for all calls");
        console2.log("[SECURITY FIX] Breeding ticket validation added");
    }
    
    function test_FIXED_MultipleRecipientsAlsoBlocked() public {
        console2.log("=== MULTIPLE RECIPIENTS ATTACK ALSO BLOCKED ===");
        
        // Attacker tries to use multiple addresses they control
        address attacker2 = makeAddr("attacker2");
        address attacker3 = makeAddr("attacker3");
        
        address[] memory recipients = new address[](3);
        recipients[0] = attacker;
        recipients[1] = attacker2;
        recipients[2] = attacker3;
        
        uint256 balanceBefore = address(vulnerableAminal).balance;
        
        vm.prank(attacker);
        vm.expectRevert("Only authorized breeding vote contract");
        vulnerableAminal.payBreedingFee(recipients, 1);
        
        // Verify no funds were stolen
        assertEq(address(vulnerableAminal).balance, balanceBefore);
        assertEq(attacker.balance, 1 ether); // Only gas money
        assertEq(attacker2.balance, 0);
        assertEq(attacker3.balance, 0);
        
        console2.log("[SECURITY FIX] Multiple recipient attacks blocked");
    }
}